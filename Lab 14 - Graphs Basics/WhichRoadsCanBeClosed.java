import java.util.*;import java.util.concurrent.LinkedBlockingQueue;/** * A class that creates a minimum spanning tree * for a given graph * The graph is represented by adjacency matrix * * @author atb * @version 4/30/2019 * @modified Ferid Ruano */public class WhichRoadsCanBeClosed{    // The matrix below represents the graph from the example provided in the lab description    // The instructor used this hardcoded matrix for testing,    // your code however must generate the matrix randomly//    private int[][] adjMatrix = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},//            {0, 0, 0, 3, 1, 0, 0, 0, 0, 0, 2},//            {0, 0, 0, 4, 0, 0, 10, 0, 0, 0, 0},//            {0, 3, 4, 0, 3, 5, 0, 0, 0, 0, 0},//            {0, 1, 0, 3, 0, 2, 0, 0, 0, 0, 0},//            {0, 0, 0, 5, 2, 0, 6, 0, 1, 0, 0},//            {0, 0, 10, 0, 0, 6, 0, 9, 10, 0, 0},//            {0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0},//            {0, 0, 0, 0, 0, 1, 10, 0, 0, 8, 0},//            {0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 10},//            {0, 2, 0, 0, 0, 0, 0, 0, 0, 10, 0}};    private int[][] adjMatrix;    private int[][] minimumSpanningTree;    private int numberOfNodes;    final int GRAYED_OUT = -1;    final int UNMARK_FOR_CHECKING = 0; // Confused me a few times    final int PERCENT100 = 100;    final int MAX_WEIGHT = 25;    public WhichRoadsCanBeClosed( int numberOfNodes, int probability )    {        //TODO Lab14b #1.1 - Done        // Initialize fields        this.numberOfNodes = numberOfNodes;        this.adjMatrix = new int[this.numberOfNodes + 1][this.numberOfNodes + 1];        this.minimumSpanningTree = new int[this.numberOfNodes + 1][this.numberOfNodes + 1];        // Create a random        Random random = new Random( 61 );        // Generate adjMatrix content        for ( int row = 1; row <= this.numberOfNodes; row++ )            for ( int col = row + 1; col <= this.numberOfNodes; col++ )                if ( random.nextInt( PERCENT100 + 1 ) <= probability )                {                    int weight = random.nextInt( MAX_WEIGHT ) + 1; // [1...MAX_WEIGHT]                    this.adjMatrix[row][col] = weight; // Top right triangle                    this.adjMatrix[col][row] = weight; // Bottom left triangle                }    }    public void displayRoadsThatCanBeClosed()    {        System.out.println( "\nThe following roads can be closed:" );        //TODO Lab14b #1.4 - Done        // Check top right triangle entries in MST against adjMatrix        for ( int row = 1; row <= numberOfNodes; row++ )            for ( int col = row + 1; col <= numberOfNodes; col++ )                if ( this.minimumSpanningTree[row][col] != this.adjMatrix[row][col] )                    System.out.printf( "%d ==== %d\n", row, col ); // Road can be closed    }    public boolean isConnected()    {        //TODO Lab14b #1.5 - Done        // utilize breath-first-traversal algorithm        boolean result = true;        final int ORIGIN = 1;        // Utilizing a boolean array to mark nodes as visited - 1 based        boolean[] visited = new boolean[this.numberOfNodes];        Queue< Integer > nodeQueue = new LinkedBlockingQueue<>();        visited[ORIGIN] = true; // Visit origin node        nodeQueue.offer( ORIGIN ); // Add origin node        // Traverse adjacency matrix        while ( !nodeQueue.isEmpty() )        {            int node = nodeQueue.poll(); // Dequeue source node            for ( int currNode = ORIGIN; currNode < this.numberOfNodes; currNode++ )                if ( !visited[currNode] && this.adjMatrix[node][currNode] != 0 )                {                    visited[currNode] = true; // Mark neighbor as visited                    nodeQueue.offer( currNode ); // Enqueue neighbor                }        }        // System.out.println("NODE QUEUE SIZE: " + nodeQueue.size()); // Does not work        // Check for all nodes were visited        for ( int i = 1; result && i < this.numberOfNodes; i++ )            if ( !visited[i] )                result = false;        return result;    }    public boolean minimumSpanningTreeCheckForCycle()    {        boolean[] visited = new boolean[this.numberOfNodes + 1];        return hasCycle( this.minimumSpanningTree, 1, visited );    }    public boolean connectedGraphCheckForCycle()    {        boolean[] visited = new boolean[this.numberOfNodes + 1];        return hasCycle( this.adjMatrix, 1, visited );    }    private boolean hasCycle( int[][] graphToCheck, int start, boolean[] visited )    {        //TODO Lab14b #1.6 - Done        visited[start] = true;        boolean result = false;        for ( int j = start + 1; !result && j <= this.numberOfNodes; j++ )        {            // if start and j are connected return true if either j was visited or recursive call starting with j returns true            if ( graphToCheck[start][j] != 0 && ( visited[j] || hasCycle( graphToCheck, j, visited ) ) )                result = true;        }        return result;    }    public void calculateMinimumSpanningTree()    {        //TODO Lab14b #1.3 - Done        // utilize findSmallestInMarkedRows method        final int MARKED = -1; // UNMARKED_FOR_CHECKING was confusing me        // Mark first row and grey-out first column        this.adjMatrix[1][0] = MARKED;        this.adjMatrix[0][1] = GRAYED_OUT;        // Generate MST using findSmallestInMarkedRows        for ( int node = 1; node < this.numberOfNodes; node++ )        {            SmallestWithIndexes smallest = findSmallestInMarkedRows();            this.minimumSpanningTree[smallest.row][smallest.column] = smallest.value;            this.minimumSpanningTree[smallest.column][smallest.row] = smallest.value;        }    }    private SmallestWithIndexes findSmallestInMarkedRows()    {        //TODO Lab14b #1.2 - Done        int smallest = this.MAX_WEIGHT;        int row = 0;        int col = 0;        final int GUTTER = 0; // Rows and cols at 0        // Traverse through adjMatrix rows        for ( int r = 1; r <= this.numberOfNodes; r++ )            // Check for marked row            if ( this.adjMatrix[r][GUTTER] != UNMARK_FOR_CHECKING )                // Traverse through adjMatrix columns                for ( int c = 1; c <= this.numberOfNodes; c++ )                    // Check for unmarked columns and non-zero entries                    if ( this.adjMatrix[GUTTER][c] != GRAYED_OUT && this.adjMatrix[r][c] != 0 )                        if ( this.adjMatrix[r][c] < smallest )                        {                            smallest = this.adjMatrix[r][c]; // New smallest                            row = r; // Set smallest entry row                            col = c; // set smallest entry col                        }        // Mark row and grey-out col        final int MARKED = -1; // UNMARKED_FOR_CHECKING was confusing me        this.adjMatrix[GUTTER][col] = GRAYED_OUT;        this.adjMatrix[col][GUTTER] = MARKED;        // System.out.println( "row= " + row + "; col= " + col + "; smallest= " + smallest );        return new SmallestWithIndexes( row, col, smallest );    }    public void displayGraph()    {        System.out.println( "***** GENERATED GRAPH *****" );        displayMatrix( this.adjMatrix );    }    public void displayMinimumSpanningTree()    {        System.out.println( "\n\n***** Computed MINIMUM SPANNING TREE for the above graph *****" );        displayMatrix( this.minimumSpanningTree );    }    private void displayMatrix( int[][] matrix )    {        System.out.print( "     " );        for ( int c = 1; c <= this.numberOfNodes; c++ )        {            System.out.printf( "[%1$2d]", c );        }        System.out.println();        for ( int r = 1; r <= this.numberOfNodes; r++ )        {            System.out.printf( "[%1$2d]", r );            for ( int c = 1; c <= this.numberOfNodes; c++ )            {                if ( matrix[r][c] > 0 )                    System.out.printf( "%1$4d", matrix[r][c] );                else                    System.out.printf( "%1$4s", " " );            }            System.out.println();        }    }    private void displayMSTinLevelOrder()    {        System.out.println( "\n\n***** Computed MINIMUM SPANNING TREE in Level-order *****" );        //TODO Lab14b #1.7 - Done        int level = 1; // Levels start at 1        final int ORIGIN = 1;        // Utilizing a boolean array to mark nodes as visited        boolean[] visited = new boolean[this.numberOfNodes];        Queue< Integer > nodeQueue = new LinkedBlockingQueue<>();        visited[0] = true;        nodeQueue.offer( ORIGIN ); // Add origin node        // Traverse MST in level order        while ( !nodeQueue.isEmpty() )        {            System.out.printf( "Level %d: ", level );            int levelSize = nodeQueue.size(); // Number of nodes in a level            // Traverse node in level            for ( int node = 0; node < levelSize; node++ )            {                int currNode = nodeQueue.remove(); // Get node at level                System.out.printf( "%d ", currNode );                // Push children of parent nodes at current level                for ( int col = 0; col <= this.numberOfNodes; col++ )                    if ( this.minimumSpanningTree[currNode][col] != 0 && !visited[col - 1] )                    {                        nodeQueue.add( col ); // Add child                        visited[col - 1] = true;                    }            }            level++; // Increment level of MST            System.out.println();        }    }    public static void main( String[] args )    {        System.out.println( "How many nodes in your graph?" );        Scanner scan = new Scanner( System.in );        int numberOfNodes = scan.nextInt();        System.out.println( "Probability of edge? (type 70 for 70%)" );        int probability = scan.nextInt();        WhichRoadsCanBeClosed graph = new WhichRoadsCanBeClosed( numberOfNodes, probability );        graph.displayGraph();        if ( graph.isConnected() )        {            if ( graph.connectedGraphCheckForCycle() )                System.out.println( "\nThe graph has cycles." );            else                System.out.println( "\nThe graph is acyclic." );            graph.calculateMinimumSpanningTree();            graph.displayMinimumSpanningTree();            graph.displayRoadsThatCanBeClosed();            if ( graph.minimumSpanningTreeCheckForCycle() )                System.out.println( "\nThe minimum spanning tree has cycles." );            else                System.out.println( "\nThe minimum spanning tree is acyclic." );            graph.displayMSTinLevelOrder();        }        else            System.out.println( "The graph is not connected, the minimum spanning tree will not be calculated" );    } // end main    private class SmallestWithIndexes    {        private int row;        private int column;        private int value;        public SmallestWithIndexes( int row, int column, int value )        {            this.row = row;            this.column = column;            this.value = value;        }    }}